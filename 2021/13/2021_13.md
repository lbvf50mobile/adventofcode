# Day 13: Transparent Origami.

The idea for the first part is to create a new field on every fold. Iterate over all cells and calculate the value of a cell on the new board by logical `OR`. The boards would contain `true/false` boolean values.

There are four types of folds.

- Horizontal fold. Top >= Bottom.
- Horizontal fold. Top < Bottom.
- Vertical fold. Left >= Right.
- Vertical fold. Left < Right.

Need to calculate.

1. Type of a fold.
2. Size of the new board.
3. Areas where dots are copied from. When two parts of the sheet covering together dot copied from both parts.

Ok. Let's make an assumption that the top part is always bigger or equal to the bottom part, and left to the right.

In this case, it is possible to create a code without a complicated update of the paper. Here are the algorithms.

### Horizontal fold.

Let's make an assumption that a top part is bigger or equal to bottom.

1. Calculate part size. `fold; height; fold = 2; height = 4; top = fold; bottom = height - 1 - fold;`
2. Check. `top >= bottom`.
3. Define stripes bounds. Inclusive `single_stripe = [0, flold - bottom - 1], double_stripe = [fold - bottom, fold - 1];`
4. Define rule for mapping for `double_stripe`. `delta = fold - i; paper[i][j] ||= paper[i+delta][j];`
5. No need to rewrite a paper, just change height. `height = fold;`

### Vertical fold.

Let's make an assumption that a left part is bigger or equal to a right part.

1. Calculate part size.
```
width = 4;
fold = 2;
left = fold;
right = width - 1 - fold;
```
2. Check. `left >= right;`
3. Define stripe bounds.
```
single_stripe = [0, fold - right - 1]
double_stripe = [fold -fright, fold - 1]
```
4. Define a rule for mapping for double stripe.

```
delta = fold - j;
paper[i][j] ||= paper[i][j+delta]
```
5. Set new width. `width = fold;`
